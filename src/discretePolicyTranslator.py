'''
****************************************************
File: discretePolicyTranslator.py
Written By: Luke Burks
May 2016

Input: File name, current pose
Output: Goal pose

The discretePolicyTranslator class is designed to 
process a robot position and use a pre-generated 
pomdp policy file to output the desired goal pose.
The current version creates a fake belief vector
from the currnet pose. Future implementations will
allow for the input of a true belief. 

Use: 
Initialize with the file name containing the policy,
represented by alpha vectors with the desired 
cardinal action as the last element. 
The desired pose is generated by the getNextPose() 
function with the current pose as an argument. 

The getNextPose() function can be called with a
"blocked" boolean which will cause the translator
to send the next goal regardless of whether the 
current goal has been reached. This is to allow
the robot to navigate around inaccessable goals.
Alternatively, the function can be called with
the "secondary" boolean, which dictates that the
translator choose the second best action to take. 


Version History:
1.0.0: initial release
1.0.1: allowed fake belief creation with floats as 
well as ints
1.0.2: getNextPose() now returns [x,y,z,theta]
1.1.0: now accepts grids of any size
1.1.1: allows for blocked paths by sending the next
	waypoint that would result from having executed
	the blocked path
	Also included an option to get the goal Pose
	that would result from taking the second best 
	action. 
****************************************************
'''


__author__ = "Luke Burks"
__copyright__ = "Copyright 2016, Cohrint"
__license__ = "GPL"
__version__ = "1.1.1"
__maintainer__ = "Luke Burks"
__email__ = "clburks9@gmail.com"
__status__ = "Development"



import random
import numpy as np
from math import sqrt




class discretePolicyTranslator():



	def __init__(self,fileName=None):
		if(fileName == None):
			self.alphas = self.readAlphas("fakealphas1.txt");
		else:
			self.alphas = self.readAlphas(fileName); 
		self.numStates = len(self.alphas[0])-1;
		self.goalX= 0; 
		self.goalY = 0; 



	def fakeBelief(self,x,y):
		arr = [0]*self.numStates;  
		arr[int(round(y))*int(sqrt(self.numStates))+int(round(x))] = 1; 
		return arr;  


	def readAlphas(self,fileName):
		file = open(fileName,"r"); 
		lines = np.loadtxt(fileName,delimiter = " "); 
		return lines; 
		
	def getAction(self,alphas,belief):
		bestValue = 0; 
		bestAction = 0; 
		 

		for i in range(0,len(alphas)):
			total = 0; 
			for j in range(0,len(belief)):
				total = total + belief[j]*alphas[i][j]; 
			if(total>bestValue):
				bestValue = total; 
				bestAction = alphas[i][len(belief)]
		return bestAction; 

	def getSecondaryAction(self,alphas,belief):
		forbiddenAction = self.getAction(alphas,belief); 

		bestValue = 0; 
		bestAction = 0; 

		for i in range(0,len(alphas)):
			total = 0; 
			if(alphas[i][len(belief)] == forbiddenAction):
				continue; 

			for j in range(0,len(belief)):
				total = total + belief[j]*alphas[i][j]; 
			if(total>bestValue):
				bestValue = total; 
				bestAction = alphas[i][len(belief)]
		return bestAction;


	def printMap(self,x,y):
		map1 = ""; 
		for i in range(int(sqrt(self.numStates))-1,-1,-1):
			for j in range(0,int(sqrt(self.numStates))):
				if(j == x and i == y):
					map1 = map1+'X'; 
				else:
					map1 = map1+"-"; 
			map1 = map1+"\n"; 
		print(map1); 


	def getCurrentPose(self):
		x = 0; 
		y = 0;
		z = 0;  
		return [x,y]; 


	#for blocked states, you can either send the next
	#way point and let the robot navigate around, or
	# you can send the second best action to take.
	def getNextPose(self,pose,blocked=False,secondary = False):
		if(blocked==False or secondary == True):
			x = int(pose[0]); 
			y = int(pose[1]); 
		else:
			x = self.goalX; 
			y = self.goalY; 
			
		belief = self.fakeBelief(x,y);  
		if(secondary == False):
			action = self.getAction(self.alphas,belief); 
		else:
			action = self.getSecondaryAction(self.alphas,belief);

		orient = 0; 

		if(action == 0):
			destX = x-1; 
			destY = y; 
			actVerb = "Left"; 
			orient = 180; 
		elif(action == 1):
			destX = x+1; 
			destY = y; 
			actVerb = "Right"; 
			orient = 0; 
		elif(action == 2):
			destX = x; 
			destY = y+1; 
			actVerb = "Up";
			orient = 90; 
		elif(action == 3):
			destX = x; 
			destY = y-1; 
			actVerb = "Down";
			orient = -90; 
		else:
			destX = x; 
			destY = y;
			actVerb = "Wait";

		self.goalX = destX; 
		self.goalY = destY; 

		return [destX,destY,0,orient]; 


	def simulate(self,T):
		#grab robots position
		#x = random.randrange(0,4); 
		#y = random.randrange(0,4);
		if(T == 0):
			x = 0; 
			y = 0; 
			#alphas = self.readAlphas("fakealphas1.txt");
		if(T == 1):
			x = 2; 
			y = 2; 
			#alphas = self.readAlphas("fakealphas2.txt");
		
		action = 0; 


		print("Origin: [" + str(x) + "," + str(y) + "]"); 
		self.printMap(x,y); 

		while(action != 4):
			belief = self.fakeBelief(x,y);  

			action = self.getAction(self.alphas,belief); 
			destX = 0; 
			destY = 0; 
			actVerb = ""; 

			if(action == 0):
				destX = x-1; 
				destY = y; 
				actVerb = "Left"; 
			elif(action == 1):
				destX = x+1; 
				destY = y; 
				actVerb = "Right"; 
			elif(action == 2):
				destX = x; 
				destY = y+1; 
				actVerb = "Up";
			elif(action == 3):
				destX = x; 
				destY = y-1; 
				actVerb = "Down";
			else:
				destX = x; 
				destY = y;
				actVerb = "Wait"; 

			

			print("Action: " + actVerb); 
			print("Destination: [" + str(destX) + "," + str(destY) + "]"); 
			self.printMap(destX,destY); 
			x = destX; 
			y = destY; 


	def runOnce(self,file = "fakealphas1.txt"):
		x = random.randrange(0,int(sqrt(self.numStates))); 
		y = random.randrange(0,int(sqrt(self.numStates)));
		belief = self.fakeBelief(x,y); 
		alphas = self.readAlphas(file); 
		action = self.getAction(alphas,belief); 

		if(action == 0):
			destX = x-1; 
			destY = y; 
			actVerb = "Left"; 
		elif(action == 1):
			destX = x+1; 
			destY = y; 
			actVerb = "Right"; 
		elif(action == 2):
			destX = x; 
			destY = y+1; 
			actVerb = "Up";
		elif(action == 3):
			destX = x; 
			destY = y-1; 
			actVerb = "Down";
		else:
			destX = x; 
			destY = y;
			actVerb = "Wait";
		print("Origin: [" + str(x) + "," + str(y) + "]");
		print("Action: " + actVerb); 
		print("Destination: [" + str(destX) + "," + str(destY) + "]"); 

	


if __name__ == "__main__":
	
	fileName = "realAlphasSpiralIn25.txt"; 
	#fileName = "fakealphas1.txt"; 
	pol = discretePolicyTranslator(fileName); 
	#pol.simulate(1); 

	'''
	post = pol.getNextPose([0,0,0],secondary=True); 
	for i in range(0,25):
		post = pol.getNextPose(post,False,False); 
		print(post); 
	'''
	





